%Pakete;
%A4, Report, 12pt
\documentclass[ngerman,a4paper,12pt]{scrreprt}
\usepackage[a4paper, right=20mm, left=20mm,top=30mm, bottom=30mm, marginparsep=5mm, marginparwidth=5mm, headheight=7mm, headsep=15mm,footskip=15mm]{geometry}

%Papierausrichtungen
\usepackage{pdflscape}
\usepackage{lscape}

%Deutsche Umlaute, Schriftart, Deutsche Bezeichnungen
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}

%quellcode
\usepackage{listings}
\usepackage{verbatim}
\usepackage{moreverb}
\let\verbatiminput=\verbatimtabinput
\def\verbatimtabsize{4\relax} 

%tabellen
\usepackage{tabularx}

%listen und aufzählungen
\usepackage{paralist}

%farben
\usepackage[svgnames,table,hyperref]{xcolor}

%symbole
\usepackage{latexsym,textcomp}
\usepackage{amssymb}

%font
\usepackage{helvet}
\renewcommand{\familydefault}{\sfdefault}

%durch- und unterstreichen
\usepackage{ulem}

%Abkürzungsverzeichnisse
\usepackage[printonlyused]{acronym}

%Bilder
\usepackage{graphicx} %Bilder
\usepackage{float}	  %"Floating" Objects, Bilder, Tabellen...
\usepackage[space]{grffile} %Leerzechen Problem bei includegraphics
\usepackage{wallpaper} %Seitenhintergrund setzen
\usepackage{transparent} %Transparenz

%Tikz, Mindmaps, Trees
\usepackage{tikz}
\usetikzlibrary{mindmap,trees}
\usepackage{verbatim}

%for
\usepackage{forloop}
\usepackage{ifthen}

%Dokumenteigenschaften
\title{Summary Dbs2}
\author{Tobias Blaser}
\date{\today{}, Uster}


%Kopf- /Fusszeile
\usepackage{fancyhdr}
\usepackage{lastpage}

\pagestyle{fancy}
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie

%Kopf-/ Fusszeile auf chapter page
\fancypagestyle{plain} {
	\fancyhf{} %alle Kopf- und Fußzeilenfelder bereinigen
	\renewcommand{\headrulewidth}{0pt} %obere Trennlinie
	\fancyfoot[L]{\jobname} %Fusszeile links
	\fancyfoot[C]{Seite \thepage/\pageref{LastPage}} %Fusszeile mitte
	\fancyfoot[R]{\today{}} %Fusszeile rechts
	\renewcommand{\footrulewidth}{0.4pt} %untere Trennlinie
}

\usepackage{changepage}

% Abkürzungen für Kapitel, Titel und Listen
\input{commands/shortcutsListAndChapter}
\input{commands/TextStructuringBoxes}

%links, verlinktes Inhaltsverzeichnis, PDF Inhaltsverzeichnis
\usepackage[bookmarks=true,
bookmarksopen=true,
bookmarksnumbered=true,
breaklinks=true,
colorlinks=true,
linkcolor=black,
anchorcolor=black,
citecolor=black,
filecolor=black,
menucolor=black,
pagecolor=black,
urlcolor=black
]{hyperref} % Paket muss unbedingt als letzes eingebunden werden!

\usepackage{graphicx}
\begin{document}

% Inhaltsverzeichnis
\tableofcontents
\clearpage

\ch{Repetition Dbs1}

\exam{'group by' wichtig}
\definition{OLTP}{Online-Transaction-Processing}

\se{ANSI Modell}
\img{img/v1.1.jpg}{ANSI 3-Ebenen Modell}{1}{}

\se{ACID}
\ul
	\li Atomizität: Eine Transaktion ist atomare Verarbeitungseinheit, die entweder vollständig oder gar
nicht ausgeführt wird.
	\li Consistency (Konsistenz): konsistenzerhaltend 
	\li Isolation: Eine T. soll so ausgeführt werden, als sei sie
isoliert von anderen
	\li Durability (Dauerhaftigkeit): Änderungen einer T.
sind dauerhaft, sie dürfen nicht aufgrund von Fehlern
verloren gehen
\ulE

\ch{Oracle's PL/SQL}
\expl{PL/SQL}{SQL ist deklarativ und beschreibt nur was, nicht wie. \textbf{Procedural Language} ermöglicht das wie.}

\img{img/v1.2.jpg}{}{0.75}{}
\ul
	\li wird kompiliert
	\li wird nahe bei den Daten im DD abgelegt
	\li Innerhalb von PL/SQL darf SQL ausgeführt werden, Resultate landen in Variablen
\ulE

\img{img/v1.3.jpg}{}{0.75}{}
\ul
	\li 'DECLARE'-Block optional
	\li Server soll Output zurückschicken: 'SQL> SET SERVEROUTPUT ON'
	\li Letzter Fehler anzeigen: 
	\li PL/SQL Blöcke müssen mit Slash abgeschlossen werden:
		\begin{verbatim}
		SQL> BEGIN
		dbms_output.put_line('Welcome to PL/SQL');
		END;
		/
		\end{verbatim}
	\li SQL> EXEC 'welcome' führt die Funktion welcome aus:
		\begin{verbatim}
		CREATE OR REPLACE PROCEDURE welcome
		IS
		user_name VARCHAR2(8) := user;
		BEGIN -- 'BEGIN'
		dbms_output.put_line('Welcome to
		PL/SQL, ' || user_name || '!');
		END;
		/
		\end{verbatim}
	\li Blöcke dürfen verschachtelt werden: im BEGIN Block dürfen wiederum DECLARE, BEGIN, End, ... Blöcke stehen.
	\li Verschachtelte Blöcke schränken Sichtbarkeit ein
	\li Resultate werden durch 'INTO varname' in Variablen gespeichert
	\li Datentyp von Tabelle übernehmen: ' Tabelle.Spalte\%TYPE;'
	\li Systemvariablen: USER, ...
	\li Exceptions:
		\begin{verbatim}
		WHEN NO_DATA_FOUND THEN
		/*System Exception:
		SELECT INTO liefert keinen Wert*/
		RAISE;
		WHEN TOO_MANY_ROWS THEN
		/*SELECT INTO* liefert mehr als einen Wert*/
		RAISE;
		WHEN DUP_VAL_ON_INDEX THEN
		/*Projektzuteilung existiert bereits*/
		\end{verbatim}
\ulE

\img{img/v1.4.jpg}{PL/SQL Block mit DECLARE, BEGIN EXCEPTION und END Block}{0.75}{}

\se{Exceptions}
Wie in Java.
\img{img/v1.5.jpg}{}{0.75}{}
\img{img/v1.6.jpg}{Benannte Benutzer AUsnahmen}{0.75}{}

\se{Stored Procedures}
\expl{SP}{DBS Subroutine}
\ul
	\li Objekte wie Tabellen, die Rechte und User zugeteilt werden
\ulE

\img{img/v1.7.jpg}{}{0.75}{}

\se{Funktionen}
\expl{Unterschied Procedure und Funktionen}{Funktionen können im SQL verwendet werden (Bps. AVG), Procedures können nur alleine ausgeführt werden.}

\important{Procedure kann nur im PL/SQL aufgerufen werden, Funktion sowohl im SQL wie PL/SQL}

\img{img/v1.8.jpg}{Vergleich}{0.75}{}

\ch{Stored Procedure in PL/SQL, Java und Python}
\ul
	\li SP werden als Block in der Datenbank abgelegt. 
	\li Im Gegensatz zum anon. Block wird die P beim Aufruf geparst und in der DB gespeichert.
	\li Vorteile: Performance, Security (Zentrale Überprüfungen, Zugriffsschutz)
	\li Nachteil: SP herstellerspezifisch, Probleme mit Optimierer
\ulE

\examp{Security}{Security: zum Lesen: Views, zum Schreiben: brauchen keine schreibrechte, nur ausführungsrechte auf Procedure. Procedure definiert genau, was übergeben werden soll und erlaubt nur dies.}

\exam{Prüfungsrelevant: \\
	1. Variablen (DECLARE), Blöcke (BEGIN...END), Konst.
	(CONSTANT) \\
	2. Typen (SQL; \%TYPE; NUMBER, SUBTYPE) \\
	3. Conditional Control Statements (IF...END IF; ) \\
	4. Sequential Control Statements (GOTO, NULL) \\
	5. Loops (LOOP, FOR...LOOP, WHILE...LOOP) \\
	6. Exception Handlers (EXCEPTION, RAISE, \\
	7. Built-In Functions: Character; Date; Numeric, LOB, and
	Miscellaneous Fns., Conversion Fns. \\
	8. Prozeduren und Funktionen (CREATE PROCEDURE...AS) \\
	9. Packages (CREATE PACKAGE; CREATE PACKAGE...BODY ) \\
	10. Cursors (FOR record\_index IN cursor\_name LOOP) \\
	11. Record Types (TYPE first\_rectype IS RECORD (var1
	VARCHAR2(100)), \%ROWTYPE)
}


\ch{IO}
\ul
	\li SET ist nicht Teil von SQL, sondern SQL plus (pakage).
	\li Output: DBMS\_OUTPUT.PUT\_LINE (Putline ist wie eine Pipe, hat nichts mit der Konsole zu tun \ra schreibt in Buffer) \\ Wichtig: SET SERVEROUTPUT ON
	\li Input: DBMS\_OUTPUT.GET\_LINE(:buffer, :status); \\ Wichtig: set echo on;
\ulE


\ch{Packages}
\ul
	\li Gruppieren PL/SQL Typen und Unterprogramme
	\li  Können nicht aufgerufen, parameterized, oder verschachtelt werden
	\li Bsp:dbms\_output, user\_lock
 \ulE
 
 \se{Package Deploying}
 \img{img/v2.1.jpg}{}{0.75}{}
 \img{img/v2.2.jpg}{}{0.75}{}

\sse{Bsp1}
\begin{verbatim}
CREATE OR REPLACE PACKAGE AngestelltenVerwaltung AS
...
FUNCTION AngEinstellen (Name VARCHAR2,..
..
END AngestelltenVerwaltung;

\end{verbatim}

\sse{Bsp2}
\begin{verbatim}
CREATE OR REPLACE PACKAGE BODY AngestelltenVerwaltung AS
...
	PROCEDURE GetAngOfAbt ( AbtNo IN NUMBER,
		..
		IS
		BEGIN
		...
	END GetAngOfAbt;
	...
END AngestelltenVerwaltung;

\end{verbatim}


\ch{Cursor}
\img{img/v2.3.jpg}{Cursor Verarbeitung}{0.75}{}
\img{img/v2.4.jpg}{Cursor Prinzip}{0.75}{}
\img{img/v2.5.jpg}{Cursor Variable}{0.75}{}

\sse{Deklaration Bsp}
\begin{verbatim}
DECLARE
CurrAbtNr integer := 1;
CURSOR AngCursor IS
SELECT Salaer, PersNr FROM Angestellter
WHERE Angestellter.AbtNr=CurrAbtNr;
SalSumme NUMBER (8, 2) := 0;
AngSalaer Angestellter.Salaer%TYPE;
AngPersNr Angestellter.PersNr%TYPE;
\end{verbatim}

\sse{Cursor Verarbeitung}
\begin{verbatim}
BEGIN
OPEN AngCursor; /*SQL-Abfrage starten und Resultat in Puffer
speichern*/
LOOP /*Iteration ueber Resulatmenge*/
FETCH AngCursor INTO AngSalaer, AngPersNr;
EXIT WHEN AngCursor%NOTFOUND OR AngCursor%ROWCOUNT>10
SalSumme := SalSumme + AngSalaer;
dbms_output.put_line('Angstellter PersNr: ' || AngPersNr ||
' Salaer: ' || AngSalaer);
END LOOP;
CLOSE AngCursor;
dbms_output.put_line('Salaersumme: ' || SalSumme);
END;

\end{verbatim}

\important{String werden in 'einfach' Hochkommas geschrieben!}

\sse{Cursor mit Parametern}
\begin{verbatim}
DECLARE
CurrAbtNr integer;
CURSOR AngCursor (AbtId IN Abteilung.AbtNr%TYPE) IS
SELECT Salaer, PersNr FROM Angestellter
WHERE Angestellter.AbtNr=AbtId;
SalSumme NUMBER (8, 2) := 0;
AngRec
 AngCursor%ROWTYPE;

\end{verbatim}

\sse{Cursor for Update}
Cursor muss für Update ``angekündigt'' werden.
\img{img/v2.6.jpg}{}{0.75}{}

\sse{Cursor Attribute}
\img{img/v2.7.jpg}{}{0.75}{}


\ch{Constraints}
\definition{Constraint}{Konsistenzbedinung, Regel der die Daten immer genügen müssen}
\expl{Implizite Constraints}{Werden durch das Schema abgedeckt, z.B. Schlüssel, Wertebereiche, Kardinalität, ...}
\expl{Primäre/Sekundäre Constraint}{Primäre ist sofort geprüft/gültig: z.B. Wertebereich, Sekundäre wird erst später geprüft: z.B. Summe von Salären, die nach dem Einfügen einer neuen Zeile erst berechnet und in Tabelle abgelegt werden muss.}
\expl{starke/schwache Constraints}{Während (stark) oder nach der Transaktion (schwach) geprüft}

\sse{Postgresql}
\img{img/v3.1.jpg}{Add Constraint}{0.75}{}
\img{img/v3.2.jpg}{Delete Constraint}{0.75}{}
\img{img/v3.3.jpg}{Enable/Disable Constraint}{0.75}{}
\img{img/v3.4.jpg}{View Constraints}{0.75}{}


\ch{Triggers}
\ul
	\li Sicherstellung komplexer Konsistenzbedingungen
	\li Werte von abgeleiteten Attributen berechnen
	\li Speichern von materialisierten Views
	\li Zugriffsschutz
	\li Kann nicht direkt aufgerufen werden, gehört immer zu einer Tabelle
	\li Wird automatisch beim Eintreten des Trigger-Events aufgerufen
\ulE

\definition{Before-Trigger}{Überprüft Vorbedinungen}
\definition{After-Trigger}{Prüft Nachbedingungen}
\definition{Row-Trigger}{Wird für jede betroffene Zeile aufgerufen}
\definition{Statement-Trigger}{Wird pro SQL-Anweisung/Ereignis aufgerufen}

\sse{Beispiel INSERT mit Bedingung}
\img{img/v3.6.jpg}{}{0.5}{}
\img{img/v3.5.jpg}{}{0.75}{}

\sse{:old, :new}
\ul
	\li bei INSERT gibt es nur :new.{object}
	\li beim DELETE gibt es nur :old.{object}
	\li bei UPDATE sind beide vorhanden
	\li referenzieren die neuen und die Alten Daten bei einer Datenbankänderung
\ulE
\important{Es gibt keinen SELECT Trigger!}

\sse{Ereignisabfrage}
\begin{verbatim}
...
IF DELETING
...
IF UPDATING
...
ELSE
...
END IF
...
\end{verbatim}

\sse{Ausführungsreihenfolge}
\img{img/v3.7.jpg}{}{0.75}{}

\sse{Login/Logoff Trigger}
Hat Zugriff auf userid und username, wird beim erfolgreichen an-/abmelden ausgelöst.

\sse{Instead-of-Trigger}
\ul
	\li Ersetzt INSERT / UPDATE / DELETE
	\li Materialisierte Views
	\li Daten statt löschen nur als gelöscht markieren
	\li Das eigentliche Originalstatement wird NICHT mehr ausgeführt
\ulE
\img{img/v3.8.jpg}{Beispiel View}{0.75}{}
\img{img/v3.9.jpg}{Beispiel View}{0.75}{}
\img{img/v3.10.jpg}{Instead-of-Trigger zur View}{0.75}{}


\se{Updatable Views / Materialized Views}
\expl{Unterschied View / Temporäre Tabelle}{Temoräre Tabelle lebt nur während Transaktion oder Session, Aktualität der temp. Table unbekannt. Biew ist immer aktuell.}
\expl{Warum kann man keinen Index auf eine View anlegen?}{Tabellendaten bringen bereits einen Index mit \ra macht keinen Sinn}
\definition{Materialisierte View}{Zwischengespeicherte View, wird nicht automatisch upgedatet}
\expl{Virtuelle Tabelle}{Foreign Data Wrappers. Bei SQLIte: Schnittstelle zu externem Storage, z.B: csv}

\exam{\\
	\examp{For each Rows}{Tabelle A mit 10 Tuppel, Hälfte von Änderung betroffen, Für wie viele Rows wird der Trigger ausgelöst? \ra 5 Mal}

	\expl{Trigger \& Locking}{Oracle lockt während dem Trigger die entsprechende Tabelle \ra Select Statement während Trigger nicht möglich}

	\expl{Trigger \& Transaktionen}{Ein Trigger läuft als Transaktion, kann in einem Trigger eine weitere Transaktion geöffnet werden? Nein.}
	
	\expl{Triggerreihenfolge}{Implementationsspezifisch}
}


\ch{Spezielle Datenstrukturen}
\se{Arrays}
\ul
	\li Alle Elemente besitzen den gleichen Datenty
	\li 
\ulE
\sse{create}
\begin{verbatim}
CREATE TABLE sal_emp (
   name text,
   pay_by_quarter integer[],
   schedule text[][]
);
\end{verbatim}
\sse{insert}
\begin{verbatim}
INSERT INTO sal_emp VALUES (
   'Bill',
   ARRAY[10000, 10000, 10000, 10000],
   ARRAY[['meeting', 'lunch'], ['training','presentation']]
);
\end{verbatim}

\sse{select}
\begin{verbatim}
SELECT ARRAY[1,2,3+4];
// returns: {1,2,7}

SELECT ARRAY( SELECT 1 + (random()*5)::int
FROM generate_series(1,6) ORDER BY 1 );
// returns e.g. : {1,2,3,4,5,5}
\end{verbatim}

\sse{subscription, slice}
\begin{verbatim}
SELECT schedule[1:2][1:1]
FROM sal_emp WHERE name = 'Bill';
//returns: {{meeting},{training}}

SELECT * FROM sal_emp
WHERE 10000 = ANY (pay_by_quarter);
// any prüft jedes Array Element, ob 10000 enthalten ist
\end{verbatim}

\sse{Array Operatoren}
\begin{verbatim}
// containing (array ist untermenge):
SELECT ARRAY[2,7] <@ ARRAY[1,7,4,2,6]; // return true

gleichheit & casting: 
SELECT ARRAY[1.1,2.1,3.1]::int[] = ARRAY[1,2,3]; // return true

// gemeinsames Element:
SELECT ARRAY[1,4,3] && ARRAY[2,1]; // return true
\end{verbatim}

\exam{Operationen nicht lesen aber schreiben können}

\ul
	\li Arrays lassen sich mit negativen Indexes anlegen (z.B: von -5 bis +5)
	\li Conversions, z.B. array to text (string\_(agg), array to rows
	\li Es ist nur möglich an den Enden des Arrays anzufügen! Kein Einfügen an Stelle 7, wenn es keine 6 gibt
	\li Array Update Varianten: Hinten anhängen / best. Wert ersetzen, mit Slice ganze Bereiche ersetzen, Array komplett ersetzen
	\li Vorsicht mit Nullelementen in Arrays
	\li Mit Bytearray können eigenen Datenstrukturen gebaut werden \ra eigener Konstruktor und eigene Lesefunktion erforderlich
	\li Zwei Konstruktoren: '{1,2,3,4}' oder ARRAY[1,2,3,4]
	\li Arrays dürfen mehrdimensional sein (integer[] darf weiteres integer[] array enthalten)
\ulE

\exam{Typische Prüfungsfrage: Resultatset von Subscript Query angeben \\
SELECT id, arr[4:6] FROM table; // liefert Element 4,5 und 6 von den Arrays, die eines besitzen, ansonsten werden nur die vorhandenen Elementen oder einen leere Menge geliefert.}

\se{Graphen}
\definition{Graph}{Knoten (Nodes/Vertices V, verbunden mit Kanten (Edges E). Graphen können gerichtet sein, Zyklen oder Pfade enthalten}

\examp{G = (V,E)}{\\ V = {A, B, C, D, E, F}\\
 E = {(A, B), (A, C), (A, D), (C,D), (C, E), (D, E), (E, F)}
 \img{img/v4.1.jpg}{}{0.25}{}
}

\se{Dictionaries}
\definition{Dictionaries}{Key-Value Pairs KVP}
\ul
	\li Postgres: hstore ( 'a=>1, a=>2'::hstore )
	\li Hstore wird als String abgelegt
	\li hstore to array liefert {a,1,b,2}
\ulE

\begin{verbatim}
// List all keys
SELECT akeys(mykvpfield) FROM ...

// Get all key-value pairs
SELECT each(mykvpfield) FROM ...

// Get key value
SELECT mykvpfield->'name' FROM ...

// Test if key exists :
... WHERE mykvpfield ? '<value>';

// Abfragen
WHERE tags @> hstore('tourism', 'zoo')
\end{verbatim}





\end{document}
